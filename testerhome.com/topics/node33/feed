<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>TesterHome 社区 移动测试基础 节点</title>
    <link>http://testerhome.com/</link>
    <description>TesterHome 社区 移动测试基础 节点最新发帖.</description>
    <item>
      <title>适合新手的 gradle 自学教程合集</title>
      <description>&lt;h4&gt;我错过了ant时代，我也错过了maven时代，但我不能错过gradle时代！&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/itfootball/article/details/42153831" target="_blank"&gt;gradle学习(1)-helloworld &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42200245" target="_blank"&gt;gradle学习(2)-基础语法 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42213127" target="_blank"&gt;gradle学习(3)-基础认识 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42214333" target="_blank"&gt;gradle学习(4)-构建java项目 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42401267" target="_blank"&gt;gradle学习(5)-创建eclipse项目 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42467807" target="_blank"&gt;gradle学习(6)-依赖管理 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42530959" target="_blank"&gt;gradle学习(7)-groovy &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42552187" target="_blank"&gt;gradle学习(8)-gradle的命令行 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42558993" target="_blank"&gt;gradle学习(9)-获取build相关信息 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42562827" target="_blank"&gt;gradle学习(10)-gui &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42563705" target="_blank"&gt;gradle学习(11)-编写构建脚本 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42596917" target="_blank"&gt;gradle学习(12)-groovy一些基础语法 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42611039" target="_blank"&gt;gradle学习(13)-有的没的 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42617719" target="_blank"&gt;gradle学习(14)-任务 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42638123" target="_blank"&gt;gradle学习(15)-任务 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42642813" target="_blank"&gt;gradle学习(16)-操作文件 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42651705" target="_blank"&gt;gradle学习(17)-被合并的ant &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42656405" target="_blank"&gt;gradle学习(18)-ant的属性 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42659033" target="_blank"&gt;gradle学习(19)-log系统 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42672271" target="_blank"&gt;gradle学习(20)-详解java插件 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42710653" target="_blank"&gt;gradle学习(21)-在eclipse中构建java项目 &lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42750749" target="_blank"&gt;gradle复习(1)-2种定义任务方式的区别&lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42918445" target="_blank"&gt;gradle复习(2)-eclipse中依赖问题&lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42919577" target="_blank"&gt;gradle复习(3)-使用TestNG&lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42963987" target="_blank"&gt;gradle复习(4)-eclipse中Cannot find System Java Compiler 问题&lt;/a&gt;&lt;br&gt;
&lt;a href="http://blog.csdn.net/itfootball/article/details/42967697" target="_blank"&gt;gradle复习(5)-Test remote debug&lt;/a&gt;&lt;/p&gt;</description>
      <author>doctorq</author>
      <pubDate>Wed, 14 Jan 2015 20:25:09 +0800</pubDate>
      <link>http://testerhome.com/topics/1867</link>
      <guid>http://testerhome.com/topics/1867</guid>
    </item>
    <item>
      <title>关于 AndroidManifest.xml </title>
      <description>&lt;p&gt;群里有很多人问AndroidManifest.xml ，在什么地方或者是做什么用的。正好这几天在看android，自己总结下，希望对于新手有帮助。&lt;/p&gt;

&lt;p&gt;AndroidManifest.xml 作用：手机组件启动，是经过android系统来启动的，在android 启动组件之前，会先读取应用的AndroidManifest.xml文件，也叫清单文件，来获知应用中是否包含该组件，如果有会直接启动该组件。可以理解是一个应用的配置文件。&lt;/p&gt;

&lt;p&gt;AndroidManifest.xml 位置：一般会放在应用目录的根目录下，方法是把.apk 更改为.zip。 解压后会看到一个 AndroidManifest.xml 文件。如图：&lt;br&gt;
&lt;img src="/photo/2015/94dc5d4b467d1bc294749aea63286777.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;另外AndroidManifest.xml 文件还包含以下信息：&lt;/p&gt;

&lt;p&gt;口：应用需要申请的权限，比如访问网络或读取用户联系人列表&lt;br&gt;
口：应用要求的最低android 版本&lt;br&gt;
口：应用将会用到的硬件或者软件，比如可能会使用到相机，蓝牙&lt;br&gt;
口：应用用的非android 标准开发库，比如Google 地图api&lt;/p&gt;

&lt;p&gt;Tips：AndroidManifest.xml，打开之后，搜索package，在后面会有package包名&lt;/p&gt;

&lt;p&gt;搜索activity ，后面会找到活动名。如图&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2015/7176f6b19573daa2f39e0e1802eb4f08.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;如果有遗漏的地方，希望大家留言补充，谢谢。&lt;/p&gt;</description>
      <author>xie_0723</author>
      <pubDate>Tue, 13 Jan 2015 13:41:18 +0800</pubDate>
      <link>http://testerhome.com/topics/1850</link>
      <guid>http://testerhome.com/topics/1850</guid>
    </item>
    <item>
      <title>Android 测试框架整理</title>
      <description>&lt;h4&gt;Instrumentation&lt;/h4&gt;
&lt;p&gt;android自带的一个测试框架. 是其他框架的基础. 在同进程中加载被测组件.&lt;br&gt;
Google出品, 因为有很多丰富的高层封装, 所以不建议直接使用.&lt;/p&gt;
&lt;h4&gt;Robotium&lt;/h4&gt;
&lt;p&gt;基于Instrumentation框架的基础, 开发的一个更强的框架. 对常用的操作进行了易用性的封装. &lt;br&gt;
是目前使用最广的框架,&lt;/p&gt;
&lt;h4&gt;Uiautomator&lt;/h4&gt;
&lt;p&gt;Google出品, Instrumentation被设计为不能跨进程测试. 所以Uiautomator就是用于弥补这个不足的.&lt;br&gt;
Uiautomator支持跨进程和UI级别的基础测试. &lt;/p&gt;
&lt;h4&gt;Appium&lt;/h4&gt;
&lt;p&gt;支持Android和iOS的测试框架. 兼容Webdriver协议. 可以使用Selenium的方式做Android的自动化.&lt;br&gt;
底层基于Selendroid和Uiautomator. &lt;/p&gt;
&lt;h4&gt;Selendroid&lt;/h4&gt;
&lt;p&gt;基于Instrumentation的一个框架. 完全兼容Webdriver协议. &lt;/p&gt;
&lt;h4&gt;Cafe&lt;/h4&gt;
&lt;p&gt;百度出品的一个框架. 基于Robotium, 并提供了跨进程的测试解决方案.&lt;/p&gt;
&lt;h4&gt;Athrun&lt;/h4&gt;
&lt;p&gt;淘宝出品, 支持Android和iOS, 提供了简化的控件封装. 目前基本不维护.. &lt;/p&gt;
&lt;h4&gt;MonkeyTalk&lt;/h4&gt;
&lt;p&gt;企业级别的一套移动测试解决方案. 功能强大. 开源的付费产品.&lt;/p&gt;
&lt;h4&gt;Calabash&lt;/h4&gt;
&lt;p&gt;基于Robotium的一个框架. 提供了BDD模式的支持. &lt;/p&gt;
&lt;h4&gt;Robolectric&lt;/h4&gt;
&lt;p&gt;在PC上模拟Android环境的一个测试框架. 可以用于做基础的单元测试和功能测试. 因为并不是真正的环境, 所以还是需要在真机上做测试&lt;/p&gt;
&lt;h4&gt;补充&lt;/h4&gt;
&lt;p&gt;今天有同事问移动测试框架. 发现网上也没个所有框架的介绍, 我就简单写在这儿, 大家自己可以回帖补充更多的框架, 或者已有框架的更多功能. 我只是先列个大纲.&lt;/p&gt;</description>
      <author>seveniruby</author>
      <pubDate>Thu, 08 Jan 2015 12:54:53 +0800</pubDate>
      <link>http://testerhome.com/topics/1799</link>
      <guid>http://testerhome.com/topics/1799</guid>
    </item>
    <item>
      <title>Gradle 中的 task 依赖</title>
      <description>&lt;p&gt;其实到现在我发现还是有一个问题我没有搞清楚，待会儿也会讲到。由谁知道的看完了告诉我下。。。&lt;/p&gt;

&lt;p&gt;还是拿之前的monkeyApplication的工程来讲，我们先使用&lt;code&gt;gradle tasks&lt;/code&gt;来查看现在的task有什么，这次主要先来看下图中高亮的这个tasks——properties&lt;br&gt;
  &lt;img src="/photo/2015/940b5d7aa2f7f0c7cb262ad1e725a605.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;这个参数能够列出root project的所有的properties。还是很有用的。&lt;/p&gt;

&lt;p&gt;之前提到过自定义task。我们先在gradle中配置一个new monkey task。如下&lt;/p&gt;
&lt;pre class="highlight shell"&gt;  task monkey &amp;lt;&amp;lt;&lt;span class="o"&gt;{&lt;/span&gt;
    println&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"I want to banana"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;我们可以通过 &lt;code&gt;gradle tasks&lt;/code&gt;来查看我们自定义的task，也可以调用task，接着我们来写一个与monkey有依赖关系的new banana task。&lt;/p&gt;
&lt;pre class="highlight shell"&gt;task banana&lt;span class="o"&gt;(&lt;/span&gt;dependsOn: monkey&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    println&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"monkey wanted"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;这里我们看到添加了一个新的banana task，同时是依赖于monkey这个task的，也就是说如果运行banana的话，monkey会被先运行，否则banana就没有人去吃了。。。接着我们用&lt;code&gt;gradle banana&lt;/code&gt;去尝试看看&lt;br&gt;
  &lt;img src="/photo/2015/5a239ea56e48c9b54eb5dbb5b949c23b.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;接着我们来看下关于task的类型，一般我们自定义的其实都是gradle中的默认类型。但如果我们想从一个task中调用一个类中的方法去运行的话，gradle配置也是有办法的。&lt;br&gt;
  我们先新增加一个类&lt;/p&gt;
&lt;pre class="highlight shell"&gt;class MonkeyEatBanana extends DefaultTask &lt;span class="o"&gt;{&lt;/span&gt;
    @Optional
    String message &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'I am monkey'&lt;/span&gt;

    @TaskAction
    def eat&lt;span class="o"&gt;(){&lt;/span&gt;
        println &lt;span class="s2"&gt;" &lt;/span&gt;&lt;span class="nv"&gt;$message&lt;/span&gt;&lt;span class="s2"&gt;, eat banana"&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;这里可以看到是extends一个默认的task，然后其中Optional是说明这个可以选择的调用，而&lt;a href="/TaskAction" class="at_user" title="@TaskAction"&gt;&lt;i&gt;@&lt;/i&gt;TaskAction&lt;/a&gt;是一个动作，只要是调用了这个方法的，带有Action标签的方法都会被调用。接着我们添加task,&lt;code&gt;task monkey1(type:MonkeyEatBanana)&lt;/code&gt;，运行&lt;br&gt;
  &lt;img src="/photo/2015/253c6b1dae2622df4985ff62393c9069.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;同样的，我们添加另外一个task，&lt;/p&gt;
&lt;pre class="highlight shell"&gt;task monkey2&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;:MonkeyEatBanana&lt;span class="o"&gt;){&lt;/span&gt;
    message &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"I am a new monkey"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;这个调用的时候，我们就可以重写带有Optional标签的方法。&lt;br&gt;
  &lt;img src="/photo/2015/e2c219bcbcb2ce170b58bccc744433fd.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;但细心的同学可以看到。。就是每次monkey这个task都会被先运行，我表示我没有明白这个其中的point，难道是task的String正则的时候bug了么。。。还求大神告知。&lt;/p&gt;

&lt;p&gt;未完待续&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Thu, 01 Jan 2015 10:56:16 +0800</pubDate>
      <link>http://testerhome.com/topics/1756</link>
      <guid>http://testerhome.com/topics/1756</guid>
    </item>
    <item>
      <title>关于 Android 和 iOS 兼容性环境的搭建</title>
      <description>&lt;p&gt;背景：&lt;br&gt;
我们准备在下一年度开始做本地兼容性测试环境的搭建，由于我们App对环境的特殊性需求，云端测试无法满足我们的要求，因此考虑在本地搭建我们自己的兼容性测试环境。&lt;/p&gt;

&lt;p&gt;现在问题来了，怎么样合理科学地搭建这套环境呢？&lt;/p&gt;

&lt;p&gt;鄙人对于这一方面没什么经验，初步考虑是对于主流热门产品和OS版本购买真机放到机房来构建，其他的采用模拟器/仿真机的形式来实现。网上的说法是兼容性主要考虑两个方面：不同的OS版本以及不同手机分辨率。&lt;/p&gt;

&lt;p&gt;想请教下各位大神，对于兼容性环境的搭建有没有什么好的建议和思路？&lt;/p&gt;

&lt;p&gt;测试系统我们已经买了一个测试管理软件，对于自动化实现运行、案例管理、设备管理这个软件已经可以实现。现在主要是想要搭建一个兼容性测试的实验室，所有的机型和系统都采购一遍肯定不现实，我想问问有没有其他的解决方案？ 例如Chrome Emulator可以很好地进行html版本的兼容性测试，有没有类似的工具可以方便地测试App版本的兼容性？&lt;br&gt;
另外，对于硬件/虚拟机的兼容性实验室搭建，也想听听经验人士的建议。&lt;/p&gt;</description>
      <author>weamylady</author>
      <pubDate>Thu, 25 Dec 2014 09:05:19 +0800</pubDate>
      <link>http://testerhome.com/topics/1730</link>
      <guid>http://testerhome.com/topics/1730</guid>
    </item>
    <item>
      <title>Gradle 学习专辑</title>
      <description>&lt;p&gt;&lt;a href="http://www.testerhome.com/topics/1128" target="_blank"&gt;gradle 初步构建（一）&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1135" target="_blank"&gt;Java Project Gradle Emma&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1136" target="_blank"&gt;Android Project Gradle jacoco&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1205" target="_blank"&gt;Android Gradle Espresso tests&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1221" target="_blank"&gt;自由的使用 gradle 构建你的应用&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1700" target="_blank"&gt;Groovy 初探（一）&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1708" target="_blank"&gt;gradle 集成修改 Android Manifest.xml 打多个包实践&lt;/a&gt;&lt;br&gt;
&lt;a href="http://www.testerhome.com/topics/1711" target="_blank"&gt;Gradle 编译交互小技巧&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;to be continued&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Mon, 22 Dec 2014 23:05:24 +0800</pubDate>
      <link>http://testerhome.com/topics/1718</link>
      <guid>http://testerhome.com/topics/1718</guid>
    </item>
    <item>
      <title>Gradle 编译交互小技巧</title>
      <description>&lt;p&gt;今天偶然在网上看到这样的小技巧，不过其实按照中Groovy的介绍，这个也是理所当然的，不过这个例子能够打开脑洞，其实啥都可以做。&lt;/p&gt;

&lt;p&gt;首先工程已经在个人开源中：&lt;a href="https://github.com/monkeytest15/Gradle_multi_apks/tree/master/monkeyApplication" rel="nofollow" target="_blank"&gt;https://github.com/monkeytest15/Gradle_multi_apks/tree/master/monkeyApplication&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果看到之前的Gradle文章的话其实可以了解到groovy是个什么语言，其次之前其实也都看到gradle的编译是运行之后可以直接产出应用的，这次我们来看下交互的模式。&lt;/p&gt;

&lt;p&gt;这个例子是为了在使用gradle编译的时候能够进行签名的定制化，我们需要在app的目录下，注意不是root project。在app的目录下的build.gradle做如下编写：&lt;/p&gt;
&lt;pre class="highlight shell"&gt;apply plugin: &lt;span class="s1"&gt;'com.android.application'&lt;/span&gt;

android &lt;span class="o"&gt;{&lt;/span&gt;
    compileSdkVersion 21
    buildToolsVersion &lt;span class="s2"&gt;"20.0.0"&lt;/span&gt;



    defaultConfig &lt;span class="o"&gt;{&lt;/span&gt;
        applicationId &lt;span class="s2"&gt;"com.example.monkey.myapplication"&lt;/span&gt;
        minSdkVersion 10
        targetSdkVersion 21
        versionCode 1
        versionName &lt;span class="s2"&gt;"1.0"&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    buildTypes &lt;span class="o"&gt;{&lt;/span&gt;
        release &lt;span class="o"&gt;{&lt;/span&gt;
            minifyEnabled &lt;span class="nb"&gt;false
            &lt;/span&gt;proguardFiles getDefaultProguardFile&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'proguard-android.txt'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="s1"&gt;'proguard-rules.pro'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    //这个是解决lint报错的代码
    lintOptions &lt;span class="o"&gt;{&lt;/span&gt;
        abortOnError &lt;span class="nb"&gt;false&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    signingConfigs &lt;span class="o"&gt;{&lt;/span&gt;
        myConfigs &lt;span class="o"&gt;{&lt;/span&gt;
            storeFile     file&lt;span class="o"&gt;(&lt;/span&gt; System.console&lt;span class="o"&gt;()&lt;/span&gt;.readLine&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n\$&lt;/span&gt;&lt;span class="s2"&gt; Enter keystore path: "&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
            storePassword       System.console&lt;span class="o"&gt;()&lt;/span&gt;.readPassword&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n\$&lt;/span&gt;&lt;span class="s2"&gt; Enter keystore password: "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            keyAlias            System.console&lt;span class="o"&gt;()&lt;/span&gt;.readLine&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n\$&lt;/span&gt;&lt;span class="s2"&gt; Enter key alias: "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            keyPassword         System.console&lt;span class="o"&gt;()&lt;/span&gt;.readPassword&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n\$&lt;/span&gt;&lt;span class="s2"&gt; Enter key password: "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    productFlavors &lt;span class="o"&gt;{&lt;/span&gt;
        qqqq &lt;span class="o"&gt;{&lt;/span&gt;
            applicationId &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'com.monkey.qqq'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        hhhhh &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="nv"&gt;applicationId&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'com.monkey.hhh'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;



dependencies &lt;span class="o"&gt;{&lt;/span&gt;
    compile fileTree&lt;span class="o"&gt;(&lt;/span&gt;dir: &lt;span class="s1"&gt;'libs'&lt;/span&gt;, include: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'*.jar'&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
    compile &lt;span class="s1"&gt;'com.android.support:appcompat-v7:21.0.3'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;/pre&gt;

&lt;p&gt;在这中间，关键代码如下：&lt;br&gt;
&lt;img src="/photo/2014/568f831668845132c935ee08196b1163.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;我们可以在编译的时候看到出现了签名的选择：&lt;br&gt;
&lt;img src="/photo/2014/2d4d3fed4a204d59fafdd1fd317eabf0.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;到此我们脑洞可以大开啦～～&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Sun, 21 Dec 2014 02:07:08 +0800</pubDate>
      <link>http://testerhome.com/topics/1711</link>
      <guid>http://testerhome.com/topics/1711</guid>
    </item>
    <item>
      <title>gradle 集成修改 Android Manifest.xml 打多个包实践</title>
      <description>&lt;p&gt;其实这次我想好好把gradle 构建android工程生成的文件好好看看的，但是实在太多了，而且网络上资料有限，故而就放在下次吧。&lt;/p&gt;

&lt;p&gt;这次做了一些新的尝试，然后也看了下一些之前没有关心的文件是啥用。&lt;/p&gt;
&lt;h4&gt;gradle-wrapper.jar&lt;/h4&gt;
&lt;p&gt;首先其实之前就看到有这个jar包，但是还没有去关心过到底是啥用。&lt;br&gt;
  Gradle Wrapper 是一种更加方便的使用gradle的方法，他包括了为支持windows的批处理脚本和支持类unix的shell脚本。这些脚本是你，在不安装gradle时候，也可以用gradle。安装wrapper只需要在你的build.gradle文件中添加如果下代码。&lt;br&gt;
  我们来看下结构&lt;/p&gt;
&lt;pre class="highlight shell"&gt;└── initial
    └── gradlew
    └──gradlew.bat
    └── gradle
       └── wrapper
           └── gradle-wrapper.jar
           └── gradle-wrapper.properties
&lt;/pre&gt;

&lt;p&gt;现在已经可以用Wrapper构建你的工程了。你将和之前一样，运行gradle build命令构建工程。&lt;br&gt;
./gradlew build&lt;br&gt;
第一行执行Gradle的版，他讲下载和缓存执行版本gradle的二进制文件。 Gradle Wrapper 文件将和代码一样提交给版本控制器，这样任何人，获取代码后，不用安装gradle，就可以构建工程。&lt;/p&gt;

&lt;p&gt;这个的确会非常方便，总体感觉以后再也不用编写什么打包脚本了。直接checkout，运行指定gradle命令即可。&lt;/p&gt;
&lt;h4&gt;多个项目&lt;/h4&gt;
&lt;p&gt;在gradle项目根目录下面我们也可以看到有一个&lt;code&gt;settings.gradle&lt;/code&gt;的文件，默认是有&lt;br&gt;
  &lt;code&gt;include ':app'&lt;/code&gt;&lt;br&gt;
  假设我们有三个项目，分别是&lt;/p&gt;
&lt;pre class="highlight shell"&gt;  MyProject/

| settings.gradle

app/
| build.gradle

app2/
| build.gradle

app3/
| build.gradle
&lt;/pre&gt;

&lt;p&gt;那么我们需要修改&lt;code&gt;settings.gradle&lt;/code&gt;，变成&lt;code&gt;include ‘:app’, ‘:app2′, ‘:app3′&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;1.0 rc的坑（转）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Error:(26, 0) Gradle DSL method not found: 'runProguard()'问题，这里是runProguard()方法被替换了，把runProguard改为minifyEnabled即可，&lt;a href="http://stackoverflow.com/questions/27016385/error26-0-gradle-dsl-method-not-found-runproguard" rel="nofollow" target="_blank"&gt;http://stackoverflow.com/questions/27016385/error26-0-gradle-dsl-method-not-found-runproguard&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Could not find property 'packageApplication' on com.android.build.gradle.internal.api.ApplicationVariantImpl_Decorated”问题，这个属性被取消了，这里是替换要输出的APK的名称，&lt;a href="http://stackoverflow.com/questions/27209188/could-not-find-property-packageapplication-on-com-android-build-gradle-interna" rel="nofollow" target="_blank"&gt;http://stackoverflow.com/questions/27209188/could-not-find-property-packageapplication-on-com-android-build-gradle-interna&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“Could not find property 'processManifest' on com.android.build.gradle.internal.api.ApplicationVariantImpl”问题，这里是由于manifest merger改动了，解决方法如下：&lt;a href="http://stackoverflow.com/questions/27302965/could-not-find-property-processmanifest-on-com-android-build-gradle-internal-a" rel="nofollow" target="_blank"&gt;http://stackoverflow.com/questions/27302965/could-not-find-property-processmanifest-on-com-android-build-gradle-internal-a&lt;/a&gt; &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;android studio中的plugin也发生了改变，将"apply plugin: 'android'"改为"apply plugin: 'com.android.application'"&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;monkey：不过1.0坑真的很多，大家自己去尝试就知道了。主要是stackoverflow上面的东西太旧。&lt;/p&gt;
&lt;h4&gt;修改app和root project中两个build.gradle&lt;/h4&gt;
&lt;p&gt;我们创建好Android application之后，可以在app目录和根目录下都看到build.gradle文件，这两个文件分别会从app层面和多个project层面进行build的管控。&lt;br&gt;
  我们先来看下根目录的gradle.build文件。&lt;/p&gt;
&lt;pre class="highlight shell"&gt;//其实这里已经有了标识，告诉大家这个是可以管控多个模块的
// Top-level build file where you can add configuration options common to all sub-projects/modules.

//编译脚本
buildscript &lt;span class="o"&gt;{&lt;/span&gt;
    repositories &lt;span class="o"&gt;{&lt;/span&gt;
//这里可以是maven，jcenter等
        jcenter&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    dependencies &lt;span class="o"&gt;{&lt;/span&gt;
        classpath &lt;span class="s1"&gt;'com.android.tools.build:gradle:1.0.0'&lt;/span&gt;

        // NOTE: Do not place your application dependencies here; they belong
        // &lt;span class="k"&gt;in &lt;/span&gt;the individual module build.gradle files
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
// 1.0 rc之后这个需要修改
apply plugin: &lt;span class="s1"&gt;'com.android.application'&lt;/span&gt;


android &lt;span class="o"&gt;{&lt;/span&gt;
    compileSdkVersion 21
    buildToolsVersion &lt;span class="s2"&gt;"20.0.0"&lt;/span&gt;

//这里需要设置资源文件，否则会报错，文件找不到
    sourceSets &lt;span class="o"&gt;{&lt;/span&gt;
        main &lt;span class="o"&gt;{&lt;/span&gt;
            manifest.srcFile &lt;span class="s1"&gt;'AndroidManifest.xml'&lt;/span&gt;
            java.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            resources.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src/main/res'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            aidl.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            renderscript.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'src'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            res.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'res/main/res'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
            assets.srcDirs &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'assets'&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        instrumentTest.setRoot&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'tests'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    defaultConfig &lt;span class="o"&gt;{&lt;/span&gt;
        applicationId &lt;span class="s2"&gt;"com.example.monkey.myapplication"&lt;/span&gt;
        minSdkVersion 10
        targetSdkVersion 21
        versionCode 1
        versionName &lt;span class="s2"&gt;"1.0"&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
//增加混淆
    buildTypes &lt;span class="o"&gt;{&lt;/span&gt;
        release &lt;span class="o"&gt;{&lt;/span&gt;
            minifyEnabled &lt;span class="nb"&gt;false
            &lt;/span&gt;proguardFiles getDefaultProguardFile&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'proguard-android.txt'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="s1"&gt;'proguard-rules.pro'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


    //这个是解决lint报错的代码
    lintOptions &lt;span class="o"&gt;{&lt;/span&gt;
        abortOnError &lt;span class="nb"&gt;false&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  // 增加签名
    signingConfigs &lt;span class="o"&gt;{&lt;/span&gt;
        myConfigs &lt;span class="o"&gt;{&lt;/span&gt;
            storeFile file&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"/Users/monkey/.android/debug.keystore"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            keyAlias &lt;span class="s2"&gt;"..."&lt;/span&gt;
            keyPassword &lt;span class="s2"&gt;"..."&lt;/span&gt;
            storePassword &lt;span class="s2"&gt;"..."&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;


&lt;span class="o"&gt;}&lt;/span&gt;


allprojects &lt;span class="o"&gt;{&lt;/span&gt;
    repositories &lt;span class="o"&gt;{&lt;/span&gt;
        jcenter&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


//替换AndroidManifest.xml的REPLACE_KEY字符串为渠道名称
android.applicationVariants.all &lt;span class="o"&gt;{&lt;/span&gt; variant -&amp;gt;
    variant.outputs.each &lt;span class="o"&gt;{&lt;/span&gt; output -&amp;gt;
        output.processManifest.doLast &lt;span class="o"&gt;{&lt;/span&gt;
            //v1.11之前这里用的copy&lt;span class="o"&gt;{}&lt;/span&gt;，我换成了文件操作，这样可以在v1.11版本正常运行，并保持文件夹整洁
            //&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;buildDir&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;是指build文件夹
            //&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;variant&lt;/span&gt;&lt;span class="p"&gt;.dirName&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;是flavor/buildtype，例如GooglePlay/release，运行时会自动生成
            //下面的路径是类似这样：build/intermediates/manifests/GooglePlay/release/AndroidManifest.xml
            def manifestFile &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;buildDir&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/intermediates/manifests/full/&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;variant&lt;/span&gt;&lt;span class="p"&gt;.dirName&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/AndroidManifest.xml"&lt;/span&gt;

            //将字符串REPLACE_KEY替换成flavor的名字
            def updatedContent &lt;span class="o"&gt;=&lt;/span&gt; new File&lt;span class="o"&gt;(&lt;/span&gt;manifestFile&lt;span class="o"&gt;)&lt;/span&gt;.getText&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'UTF-8'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;.replaceAll&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"REPLACE_KEY"&lt;/span&gt;, &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;variant&lt;/span&gt;&lt;span class="p"&gt;.productFlavors[0].name&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            new File&lt;span class="o"&gt;(&lt;/span&gt;manifestFile&lt;span class="o"&gt;)&lt;/span&gt;.write&lt;span class="o"&gt;(&lt;/span&gt;updatedContent, &lt;span class="s1"&gt;'UTF-8'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

            //将此次flavor的AndroidManifest.xml文件指定为我们修改过的这个文件
            variant.processResources.manifestFile &lt;span class="o"&gt;=&lt;/span&gt; file&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;buildDir&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/intermediates/manifests/full/&lt;/span&gt;&lt;span class="k"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;variant&lt;/span&gt;&lt;span class="p"&gt;.dirName&lt;/span&gt;&lt;span class="k"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;/AndroidManifest.xml"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;/pre&gt;

&lt;p&gt;接着看下app下面的build.gradle&lt;/p&gt;
&lt;pre class="highlight shell"&gt;//增加application的apply
apply plugin: &lt;span class="s1"&gt;'com.android.application'&lt;/span&gt;

android &lt;span class="o"&gt;{&lt;/span&gt;
//配置sdk版本
    compileSdkVersion 21
    buildToolsVersion &lt;span class="s2"&gt;"20.0.0"&lt;/span&gt;



    defaultConfig &lt;span class="o"&gt;{&lt;/span&gt;
        applicationId &lt;span class="s2"&gt;"com.example.monkey.myapplication"&lt;/span&gt;
        minSdkVersion 10
        targetSdkVersion 21
        versionCode 1
        versionName &lt;span class="s2"&gt;"1.0"&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    buildTypes &lt;span class="o"&gt;{&lt;/span&gt;
        release &lt;span class="o"&gt;{&lt;/span&gt;
            minifyEnabled &lt;span class="nb"&gt;false
            &lt;/span&gt;proguardFiles getDefaultProguardFile&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'proguard-android.txt'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="s1"&gt;'proguard-rules.pro'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    //这个是解决lint报错的代码
    lintOptions &lt;span class="o"&gt;{&lt;/span&gt;
        abortOnError &lt;span class="nb"&gt;false&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    signingConfigs &lt;span class="o"&gt;{&lt;/span&gt;
        myConfigs &lt;span class="o"&gt;{&lt;/span&gt;
            storeFile file&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"/Users/monkey/.android/debug.keystore"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
            keyAlias &lt;span class="s2"&gt;"..."&lt;/span&gt;
            keyPassword &lt;span class="s2"&gt;"..."&lt;/span&gt;
            storePassword &lt;span class="s2"&gt;"..."&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
//增加多个打包渠道配置
    productFlavors &lt;span class="o"&gt;{&lt;/span&gt;
        qqqq &lt;span class="o"&gt;{&lt;/span&gt;
            applicationId &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'com.monkey.qqq'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        hhhhh &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="nv"&gt;applicationId&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'com.monkey.hhh'&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;



dependencies &lt;span class="o"&gt;{&lt;/span&gt;
    compile fileTree&lt;span class="o"&gt;(&lt;/span&gt;dir: &lt;span class="s1"&gt;'libs'&lt;/span&gt;, include: &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'*.jar'&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
    compile &lt;span class="s1"&gt;'com.android.support:appcompat-v7:21.0.3'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;/pre&gt;

&lt;p&gt;我们使用gradlew进行编译之后，我们可以在如下目录下中找到分别为了打不同包所用的Android Manifest.xml文件。&lt;br&gt;
&lt;img src="/photo/2014/b246cf0346e80846398d2c8d3c9b4419.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;同时我们也可以在outputs中的apk看到我们编译出的多个apk，但这里只是package name不同，渠道的meta data并没有修改，但是方法是一样的。&lt;br&gt;
&lt;img src="/photo/2014/a229a05ad91c748a3b4ddb76655adf04.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;最后的给个编译report。&lt;/p&gt;
&lt;pre class="highlight shell"&gt;ec2-54-67-1-101:monkeyApplication monkey&lt;span class="nv"&gt;$ &lt;/span&gt;./gradlew app:assembleDebug
:app:preBuild
:app:compileHhhhhDebugNdk UP-TO-DATE
:app:preHhhhhDebugBuild
:app:checkHhhhhDebugManifest
:app:preHhhhhReleaseBuild
:app:preQqqqDebugBuild
:app:preQqqqReleaseBuild
:app:prepareComAndroidSupportAppcompatV72103Library UP-TO-DATE
:app:prepareComAndroidSupportSupportV42103Library UP-TO-DATE
:app:prepareHhhhhDebugDependencies
:app:compileHhhhhDebugAidl UP-TO-DATE
:app:compileHhhhhDebugRenderscript UP-TO-DATE
:app:generateHhhhhDebugBuildConfig UP-TO-DATE
:app:generateHhhhhDebugAssets UP-TO-DATE
:app:mergeHhhhhDebugAssets UP-TO-DATE
:app:generateHhhhhDebugResValues UP-TO-DATE
:app:generateHhhhhDebugResources UP-TO-DATE
:app:mergeHhhhhDebugResources UP-TO-DATE
:app:processHhhhhDebugManifest UP-TO-DATE
:app:processHhhhhDebugResources UP-TO-DATE
:app:generateHhhhhDebugSources UP-TO-DATE
:app:compileHhhhhDebugJava UP-TO-DATE
:app:preDexHhhhhDebug UP-TO-DATE
:app:dexHhhhhDebug UP-TO-DATE
:app:processHhhhhDebugJavaRes UP-TO-DATE
:app:validateDebugSigning
:app:packageHhhhhDebug UP-TO-DATE
:app:zipalignHhhhhDebug UP-TO-DATE
:app:assembleHhhhhDebug UP-TO-DATE
:app:compileQqqqDebugNdk UP-TO-DATE
:app:checkQqqqDebugManifest
:app:prepareQqqqDebugDependencies
:app:compileQqqqDebugAidl UP-TO-DATE
:app:compileQqqqDebugRenderscript UP-TO-DATE
:app:generateQqqqDebugBuildConfig UP-TO-DATE
:app:generateQqqqDebugAssets UP-TO-DATE
:app:mergeQqqqDebugAssets UP-TO-DATE
:app:generateQqqqDebugResValues UP-TO-DATE
:app:generateQqqqDebugResources UP-TO-DATE
:app:mergeQqqqDebugResources UP-TO-DATE
:app:processQqqqDebugManifest UP-TO-DATE
:app:processQqqqDebugResources UP-TO-DATE
:app:generateQqqqDebugSources UP-TO-DATE
:app:compileQqqqDebugJava UP-TO-DATE
:app:preDexQqqqDebug UP-TO-DATE
:app:dexQqqqDebug UP-TO-DATE
:app:processQqqqDebugJavaRes UP-TO-DATE
:app:packageQqqqDebug UP-TO-DATE
:app:zipalignQqqqDebug UP-TO-DATE
:app:assembleQqqqDebug UP-TO-DATE
:app:assembleDebug UP-TO-DATE

BUILD SUCCESSFUL

Total &lt;span class="nb"&gt;time&lt;/span&gt;: 8.73 secs

&lt;/pre&gt;

&lt;p&gt;总体来讲，gradle的编译会比以往的mvn的pom配置文件来的更灵活，可配置性更强。关于更多的配置见之后的文章吧&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Fri, 19 Dec 2014 16:21:14 +0800</pubDate>
      <link>http://testerhome.com/topics/1708</link>
      <guid>http://testerhome.com/topics/1708</guid>
    </item>
    <item>
      <title>Groovy 初探（一）</title>
      <description>&lt;h4&gt;前言&lt;/h4&gt;
&lt;p&gt;最近在折腾gradle，到底找资料，已经找到youtube上面去了，我给跪了。&lt;br&gt;
  DSL使用groovy的语法，故而还是按照学习的流程来看，先去看看了groovy了，原谅我的无知。。。。&lt;/p&gt;
&lt;h4&gt;环境准备&lt;/h4&gt;
&lt;p&gt;说实话，开了vpn，下载到软。。。不过还好下载完毕，设置系统环境变量&lt;/p&gt;
&lt;h4&gt;尝试&lt;/h4&gt;
&lt;p&gt;检查环境&lt;br&gt;
  &lt;img src="/photo/2014/f1f4be737fd6c0e33473f6a69fbb0d4c.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;groovy其实就是一个阉割版的java，简单我们看个例子就明白了。我们编写一个demo.groovy&lt;/p&gt;
&lt;pre class="highlight java"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Hello&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;who&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="s"&gt;"hello ${who}"&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;接着使用命令行执行&lt;code&gt;groovyc demo.groovy&lt;/code&gt;，ls之后可以看到多出一个demo.class文件&lt;/p&gt;

&lt;p&gt;同样的，我们有了类之后，我们需要编写一个main方法进行调用。我们继续编写main.groovy&lt;/p&gt;
&lt;pre class="highlight java"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;hello&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"groovy"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;同样的执行groovyc之后看到出现main.class文件。&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/d8e4de712b250fdded69cdf907f84b58.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;接着我们就可以使用java的方式进行运行，看看运行结果&lt;br&gt;
&lt;img src="/photo/2014/b17c95b01ec263e711425abd10fb0038.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;###其他&lt;br&gt;
  groovy还提供很多很便捷的模式。比如输入&lt;code&gt;groovysh&lt;/code&gt;可以进行类似于python的交互模式。&lt;br&gt;
  &lt;img src="/photo/2014/e5b794ea9b8777cda4953fc139398de4.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;groovy还提供了简单的调试模式。输入&lt;code&gt;groovyConsole&amp;amp;&lt;/code&gt;&lt;br&gt;
  &lt;img src="/photo/2014/0565089efd56a0eb8bf31215229db602.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;###gradle 中增加task&lt;br&gt;
  我们可以在build.gradle中自定义groovy方法，也就是task。比如我们在某gradle工程中增加如下方法：&lt;/p&gt;
&lt;pre class="highlight java"&gt;  &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="n"&gt;groovyStudy&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++){&lt;/span&gt;
            &lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;

    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;我们使用&lt;code&gt;gradle tasks&lt;/code&gt;查看之后，可以看到groovyStudy这个task。&lt;br&gt;
&lt;img src="/photo/2014/f147ca37671e29aee7b416f4eb973e22.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;接着我们可以使用&lt;code&gt;gradle groovyStudy&lt;/code&gt;进行调用task方法&lt;br&gt;
&lt;img src="/photo/2014/43fd364e82fec0ed5c80cb7957212869.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;不过gradle的配置文件里面若干配置项还是太复杂，之后再详细文章描述吧。&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Tue, 16 Dec 2014 10:51:23 +0800</pubDate>
      <link>http://testerhome.com/topics/1700</link>
      <guid>http://testerhome.com/topics/1700</guid>
    </item>
    <item>
      <title>chrome mobile emulation 及周边漫谈和相关应用+想法</title>
      <description>&lt;h4&gt;写在前面的一些废话&lt;/h4&gt;
&lt;p&gt;首先，感谢各位一直以来对我个人的帮助和支持，很久没有在Testerhome发一弹技术帖了，最近总给人一种不务正业的感觉......大家都知道我目前已经转向苦逼的前端开发，在这个转变的过程中，我个人对移动端的一些测试形态有了一些新想法，今天就来聊聊如题所说的这些事儿。&lt;/p&gt;

&lt;p&gt;以下一些实例中涉及到了我目前所在公司的网站及其产品，确实有广告嫌疑，但是产品的h5端是由我本人开发，所以我觉得我暂时找不到更合适的例子了......&lt;/p&gt;
&lt;h4&gt;首先还是来谈谈chrome mobile emulation&lt;/h4&gt;
&lt;p&gt;OK，我还是先来聊聊chrome的mobile emulation，其实做前端开发的童鞋应该都知道他在chrome里的位置，比较害羞，比较隐蔽，而且只有在chrome 32之上的版本才能看到她，现在越来越强大了，他最直观的作用是模拟各种主流移动设备及其相关参数：通用尺寸，pixelRatio设备像素比（这也是一个大话题，暂时不用关注）等，举一个最简单的例子，当你直接打开某网站的时候默认看到的是pc版：&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/5c5259b87997f79150e492c51acdda47.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;但是，众所周知的原因，现在几乎所有的主流网站都会配备一个移动设备适配版，一般称之为“触屏版”，技术上采用html5开发，其实今天我们需要解决的主要问题就是如何来测试这种形态下产品的兼容性以及如何自动化。&lt;/p&gt;

&lt;p&gt;一切从我们按下著名的F12键开始......&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/6c2caa72086a9fd544c4bd508d5ba202.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;注意左上角类似手机的图标，当这个图标激活之后，我们将看到我们的"触屏版"在不同设备下的表现：&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/7acfad7fec6a4187886d55bc16eae71e.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;大家可以试着打开淘宝网简单地体验一下。&lt;br&gt;
我们可以看到，它可以模拟出当前的一些主流设备，从手机到平板，应有尽有，连我们最近的土豪6plus都赫然在列：&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/4ea187006d9e521ef0fcce9384f587fa.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;值得一提的是，它还有一些令人兴奋的调试参数，比如右上角可以模拟网络类型，这无论对于研发还是测试来说都是不可多得的好工具：&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/b405bd2f7120f6f38e12ab454b449b10.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;当你调节完你所需要的所有场景参数时，你就可以慢慢体验了，说再多也抵不过一张动态图：&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/ea16a932c667e86aeb0446c165d0d4ac.gif" alt=""&gt;&lt;/p&gt;

&lt;p&gt;ps：在emulation中，所有的移动端touch事件将开始生效，也就是说，前端开发人员所写的一些只为适配移动设备的事件在这里可以完美运行。&lt;/p&gt;
&lt;h4&gt;从测试角度而言，我们可以利用它做什么？&lt;/h4&gt;
&lt;p&gt;从手工测试角度来说，这款工具无疑给我们带来了很多好处。不必再次强调之。&lt;br&gt;
从自动化角度来说，chrome emulation能为我们带来遐想空间，并驱动我们去实现它。&lt;/p&gt;

&lt;p&gt;从价值来说，利用chrome emulation，我们可以做到web产品"触屏版"在各个主流设备及相关浏览器下的表现能力，并利用持续集成平台完成这个伟大的目标。&lt;/p&gt;
&lt;h4&gt;how do？&lt;/h4&gt;
&lt;p&gt;要完成这样的一个自动化，我们首先不该沉溺在一些老的资料里，而是应该多关注官方的一些文档。不用担心找不到，因为一旦有了想法，这些资料自然会被你挖掘到，看你想不想......这不，我在ChromeDriver website上，找到了这样一个官方说明：&lt;/p&gt;

&lt;p&gt;在chromedriver &amp;gt;= 2.11的release版本中才开始加入对这一特性的支持。注意：最新的chromedriver的release版本号为2.13，这也意味着，这个特性刚支持不久，各位可以尽情发挥。&lt;/p&gt;

&lt;p&gt;链接：&lt;a href="https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation" rel="nofollow" target="_blank"&gt;https://sites.google.com/a/chromium.org/chromedriver/mobile-emulation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mobile Emulation&lt;br&gt;
Chrome allows users to emulate Chrome on a mobile device (e.g. a “Google Nexus 7” tablet, or an “Apple iPhone 5”) from the desktop version of Chrome, by enabling the Mobile Emulation feature in Chrome DevTools. This feature speeds up web development, allows developers to quickly test how a website will render in a mobile device, without requiring a real device. ChromeDriver can also enable Mobile Emulation, via the “mobileEmulation” capability, specified with a dictionary value.&lt;/p&gt;

&lt;p&gt;Just as in the DevTools Emulation panel, there are two ways in ChromeDriver to enable Mobile Emulation: by specifying a known device, or by specifying individual device attributes. The format of the “mobileEmulation” dictionary depends on which method is desired.&lt;br&gt;
Specifying a Known Mobile Device&lt;br&gt;
To enable Mobile Emulation with a specific device name, the “mobileEmulation” dictionary must contain a “deviceName.” Use a valid device name from the DevTools Emulation panel as the value for “deviceName.”&lt;/p&gt;

&lt;p&gt;真是令人兴奋的一段描述，官方还给出了两个example，这里我只以python为例讲解：&lt;/p&gt;
&lt;h4&gt;直接模拟一个已存在的主流设备&lt;/h4&gt;&lt;pre class="highlight python"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="n"&gt;mobile_emulation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;"deviceName"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"Google Nexus 5"&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;chrome_options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ChromeOptions&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#  ChromeOptions实例,也算非常常用的一个类了。&lt;/span&gt;
&lt;span class="n"&gt;chrome_options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_experimental_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"mobileEmulation"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mobile_emulation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Remote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command_executor&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;'http://127.0.0.1:4444/wd/hub'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;desired_capabilities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;chrome_options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;to_capabilities&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;
&lt;h4&gt;完全自定义一个带参数的设备&lt;/h4&gt;
&lt;p&gt;当我们需要模拟一些通用参数或者不存在的设备浏览器类型时，可以采用这种高度自定义的方法：&lt;/p&gt;
&lt;pre class="highlight python"&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding:utf-8 -*-&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.chrome.options&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Options&lt;/span&gt;
&lt;span class="n"&gt;mobile_emulation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"deviceMetrics"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"width"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;360&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"height"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;640&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"pixelRatio"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="c"&gt;#  定义设备高宽，像素比&lt;/span&gt;
    &lt;span class="s"&gt;"userAgent"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;"Mozilla/5.0 (Linux; Android 4.2.1; en-us; Nexus 5 Build/JOP40D) "&lt;/span&gt; &lt;span class="c"&gt;# 通过ua来模拟&lt;/span&gt;
                 &lt;span class="s"&gt;"AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Mobile Safari/535.19"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;chrome_options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Options&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;chrome_options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_experimental_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"mobileEmulation"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mobile_emulation&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Chrome&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chrome_options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;chrome_options&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"http://www.taobao.com"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;我们运行起来看看，It works！&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/f9a59cced689a9a75a4dcb4cb9e3d12b.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;到这里，我们顺利地通过chrome driver拉起了一个触屏版demo，这个例子中，需要强调的是UA参数。&lt;/p&gt;

&lt;p&gt;在主流的前端开发技术中，为了适配各种第三方移动端浏览器，一般都是通过其特定的UA头来进行判断的，通过UA头再给出对应容器下的展现。这也意味着，我们使用这种方法，可以模拟我们的产品在微信/UC浏览器/QQ手机浏览器等国产环境下的表现......&lt;/p&gt;
&lt;h4&gt;总结与想法&lt;/h4&gt;
&lt;p&gt;目前而言，web触屏版形态的展现非常主流（特别是一些互联网产品），掌握这些务实的技巧就显得很有必要。为此，我一直觉得：测试人员的思路只要稍微发散一些，可以带来无尽可能，不必钻牛角尖，最后得不偿失。&lt;/p&gt;
&lt;h4&gt;推荐的发散思路、工具等&lt;/h4&gt;
&lt;p&gt;下面是一些想法，工具，有兴趣的同学可以自行往下研究。&lt;/p&gt;

&lt;p&gt;首先，我觉得了解web触屏版开发中，那些为了支持移动设备特性，前端开发人员常用的基础技巧很重要。&lt;br&gt;
其次：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;适当了解一下ua，js针对移动设备的主流事件，webkit独有的一些特性，了解常用移动端浏览器引擎（通常指渲染引擎）&lt;/li&gt;
&lt;li&gt;最大化节约测试成本是得到自动化成果的最务实手段。&lt;/li&gt;
&lt;li&gt;了解PhantomJS等工具，了解webkit的自动化测试的特点。&lt;/li&gt;
&lt;li&gt;了解一些常用的前端debug工具和远程调试工具（weinre等）&lt;/li&gt;
&lt;li&gt;时刻关注自动化主流工具/技术的最新版本和最新官方资讯（极为重要，对一些特性猜测保持技术敏感）&lt;/li&gt;
&lt;li&gt;当然，我始终认为，第五点是建立在有把梯子的基础上的......&lt;/li&gt;
&lt;li&gt;适当了解一些性能测试的思路和意识，而不仅仅总是那几款工具（lr,jmeter）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以戳我在SegmentFault上的一篇帖子：&lt;br&gt;
《前端测试自动化工具 + 页面性能分析工具 BerserkJS 试用小记》&lt;br&gt;
&lt;a href="http://segmentfault.com/blog/diggerplus/1190000000695819" rel="nofollow" target="_blank"&gt;http://segmentfault.com/blog/diggerplus/1190000000695819&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;解答一些群里有人问我的问题&lt;/h4&gt;
&lt;p&gt;Q： 移动端/web自动化的client能否用javascript编写？&lt;/p&gt;

&lt;p&gt;A：了解一下Node.js，npm包中有selenium webdriver的模块，上述的例子用js写，大概长这样：&lt;/p&gt;
&lt;pre class="highlight javascript"&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;webdriver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;require&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'selenium-webdriver'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;capabilities&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="na"&gt;browserName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'chrome'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="na"&gt;chromeOptions&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="na"&gt;mobileEmulation&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="na"&gt;deviceName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Apple iPhone 5'&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt;
  &lt;span class="nx"&gt;driver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;webdriver&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Builder&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;withCapabilities&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;capabilities&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;build&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nx"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'http://taobao.com'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;至于appium，npm里躺着的就更多了，但是多数是服务端。&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/85b6527cbb550cf28d5622c0d6fec11a.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;Q:  提问者自认为小白的一些问题&lt;/p&gt;

&lt;p&gt;A:  这个，我个人建议去看我的另外一篇帖子《重拾提问的艺术》，不装逼地讲，这篇文章我认为逼格还是可以的，而且务实。&lt;/p&gt;
&lt;h4&gt;送梯子一把&lt;/h4&gt;
&lt;p&gt;作为一名长期技术工作者，梯子已经成为了一个必备工具，之前我可能还会推荐朋友使用wallproxy之类的开源项目，不过gae的速度简直......所以我决定隆重推荐国内的一个vpn产品，想要了解的同学可以戳我的邀请链接：&lt;br&gt;
&lt;a href="http://findtizi.com/?r=97d149bebfb3f3f8" rel="nofollow" target="_blank"&gt;http://findtizi.com/?r=97d149bebfb3f3f8&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;最后才是广告&lt;/h4&gt;
&lt;p&gt;我的全新个人博客 &lt;a href="http://xiaoa.name" rel="nofollow" target="_blank"&gt;http://xiaoa.name&lt;/a&gt; 悄然上线了，虽然文章目前都是假的，功能还在完善中......&lt;br&gt;
托管在国内的gitcafe，代码同步在gitcafe和github，欢迎交流。&lt;/p&gt;
&lt;h4&gt;PS&lt;/h4&gt;
&lt;p&gt;这个帖子总共经历我几块牛排，一碗鱼汤，一碗蛋炒饭，几颗草莓的时间，所以，我认为信息量还是可以的。&lt;br&gt;
语句不通顺之处可以指出，我会持续更新和优化。&lt;/p&gt;
&lt;h4&gt;补刀内容赏析，欢迎热烈讨论。&lt;/h4&gt;
&lt;p&gt;来自 @思寒 &lt;/p&gt;

&lt;p&gt;我这边补刀下.&lt;br&gt;
优点&lt;br&gt;
1. 这个方法基于chrome, 可以便捷的识别跨尺寸的兼容问题. 简直就可以分分钟帮企业做个自动化服务了.&lt;br&gt;
2. 获取响应速度的瀑布流图也非常的容易. 很容易做性能测试和瓶颈分析&lt;/p&gt;

&lt;p&gt;缺点&lt;br&gt;
1. 方法基于chrome引擎, 考虑到不同浏览器的版本, 以及不同设备上浏览器引擎差异, 所以有些css的兼容性问题仍然需要验证. 所以尺寸兼容性可以解决, 但是设备的兼容性测试仍然需要做. 好消息是大部分企业的h5一般都是布局不合理占多数.&lt;/p&gt;</description>
      <author>qddegtya</author>
      <pubDate>Mon, 15 Dec 2014 20:05:33 +0800</pubDate>
      <link>http://testerhome.com/topics/1697</link>
      <guid>http://testerhome.com/topics/1697</guid>
    </item>
    <item>
      <title>谁有轻量级的 Android 模拟器推荐？ 电脑内存 1G 上可流畅运行的</title>
      <description>&lt;p&gt;最近要解决一个需求，需要一个轻量级流畅的简单AVD，只需要能运行App用来给客服人员用，他们的电脑都非常烂，只有1G内存的。&lt;/p&gt;

&lt;p&gt;网上查阅了很多资料，找到了一个削减到只有150M大小的Emulator Image，然后设置一些参数如下，也会快一些，但是始终还是太慢~~ 而HAXM加速技术，CPU又太烂不支持。&lt;/p&gt;
&lt;pre class="highlight shell"&gt;emulator.exe -cpu-delay 0 -gpu on -netfast -nojni -noaudio -no-boot-anim -memory 128 -skindir . -skin XXX -qemu -icount auto
&lt;/pre&gt;

&lt;p&gt;网上有推荐blustacks的，根本安装不上。有推荐Genymotion的，这个还是不够轻量级，不好推广。谁有较合适的工具推荐下？&lt;/p&gt;</description>
      <author>weamylady</author>
      <pubDate>Mon, 15 Dec 2014 14:53:45 +0800</pubDate>
      <link>http://testerhome.com/topics/1696</link>
      <guid>http://testerhome.com/topics/1696</guid>
    </item>
    <item>
      <title>SDK 测试小结</title>
      <description>&lt;p&gt;自己总结了一下SDK中接口的测试点，希望各位高手予以补充和纠正（下面提到的大部分是有网络请求的接口）&lt;br&gt;
1、全新sdk&lt;br&gt;
1.1、了解业务流程，确定开放给开发者都有哪些接口&lt;br&gt;
1.2、了解SDK用到的所有协议，每个协议中字段的意义和作用以及server端处理逻辑&lt;br&gt;
1.3、接口要校验输入参数各种输入情况是否能正确处理，返回值的正确性，是否有数据缓存到本地，检查是否有回调，如果有对于请求成功、请求失败（包括无网络、服务器返回非200错误代码）是否都有调用&lt;br&gt;
1.4、测试中对每个请求都应该抓包测试，查看请求的字段、参数值、返回值是否正确&lt;br&gt;
1.5、对于协议中必传字段，SDK中是否校验为空的情况&lt;br&gt;
1.6、查看是否存在多发、少发请求的情况&lt;br&gt;
1.7、对于异步请求的结果在其他地方（A类中）会用到的情况，检查是否存在网络较慢情况下，未完成请求数据为空时A类就用到数据&lt;/p&gt;

&lt;p&gt;2、对于SDK更新&lt;br&gt;
2.1、对于增加接口，要确定新增接口对应的协议及各字段的意义&lt;br&gt;
2.2、对于增加接口调用新接口时要进行抓包，确定发送请求的参数、返回值与协议一致&lt;br&gt;
2.3、对于删除、新增接口都应在集成文档中说明&lt;br&gt;
2.4、对于删除、新增接口都应确保对于老接口没有影响&lt;br&gt;
2.5、SDK更新时，对于有用户数据的情况，要考虑旧SDK没有数据，更新新SDK，新SDK是否可以使用；旧SDK已有用户数据，更新新SDK后旧数据是否存在&lt;/p&gt;

&lt;p&gt;3、上线前检查&lt;br&gt;
3.1、头文件注释部分&lt;br&gt;
3.2、增加API，头文件更新API&lt;br&gt;
3.3、删除API，头文件删除API&lt;br&gt;
3.4、检查包名、版本，测试中url是否存在测试用的端口或url，发布时应改成正式环境&lt;br&gt;
3.5、检查包大小及包的架构检查（ios 如armv7/armv7s/armv64）&lt;br&gt;
3.6、检查&lt;/p&gt;

&lt;p&gt;4、上线后检查&lt;br&gt;
4.1、进行上线回归测试&lt;br&gt;
4.2、检查文档更新&lt;br&gt;
4.3、是否上传至cocoapods&lt;/p&gt;</description>
      <author>lifreshman</author>
      <pubDate>Thu, 04 Dec 2014 21:11:24 +0800</pubDate>
      <link>http://testerhome.com/topics/1660</link>
      <guid>http://testerhome.com/topics/1660</guid>
    </item>
    <item>
      <title>移动应用自动化测试的困惑</title>
      <description>&lt;p&gt;在我实施移动应用自动化测试的过程当中，我思考最多的倒不是技术实现上面的问题，而是：&lt;br&gt;
1. 面对迭代周期短的应用，自动化的开发维护成本实在太高，那是否有必要做自动化？&lt;br&gt;
2. UI的自动化的产出是很少的，发现不了什么问题，是否有必要自动化？&lt;br&gt;
我始终在思考UI自动化的意义，UI自动化产生的价值有多少？&lt;br&gt;
我目前的想法是前端UI和功能的测试全部手工执行，接口的测试实行自动化&lt;br&gt;
对于上面的2个问题，期望移动应用测试大神来释疑，谢谢！&lt;/p&gt;</description>
      <author>kevin_xu_v</author>
      <pubDate>Mon, 17 Nov 2014 11:48:06 +0800</pubDate>
      <link>http://testerhome.com/topics/1587</link>
      <guid>http://testerhome.com/topics/1587</guid>
    </item>
    <item>
      <title>DDMS 中生成 Trace 的方法原理是什么</title>
      <description>&lt;p&gt;&lt;a href="http://developer.android.com/tools/debugging/debugging-tracing.html" rel="nofollow" target="_blank"&gt;http://developer.android.com/tools/debugging/debugging-tracing.html&lt;/a&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;There are two ways to generate trace logs:

第一种
Include the Debug class in your code and call its methods such as startMethodTracing() and stopMethodTracing(), to start and stop logging of trace information to disk. This option is very precise because you can specify exactly where to start and stop logging trace data in your code.

第二种
Use the method profiling feature of DDMS to generate trace logs. This option is less precise because you do not modify code, but rather specify when to start and stop logging with DDMS. Although you have less control on exactly where logging starts and stops, this option is useful if you don't have access to the application's code, or if you do not need precise log timing.
&lt;/pre&gt;

&lt;p&gt;我好奇的是第二种方法, 他底层的原理是什么, 大家有了解的吗?&lt;br&gt;
是通过往ADB或者JDB发送什么指令吗?&lt;/p&gt;</description>
      <author>seveniruby</author>
      <pubDate>Sat, 08 Nov 2014 02:13:06 +0800</pubDate>
      <link>http://testerhome.com/topics/1567</link>
      <guid>http://testerhome.com/topics/1567</guid>
    </item>
    <item>
      <title>uiautomatorviewer 不能显示模拟器界面，黑屏，但是信息能出来？谁知道怎么回事？</title>
      <description>&lt;p&gt;&lt;img src="/photo/2014/87913869a03dce4a89def12e238457ed.jpg" alt=""&gt;&lt;br&gt;
如图，今天想要查看某个元素的信息，结果打开后，发现黑屏，直接傻眼了，有谁遇到过？&lt;/p&gt;</description>
      <author>qileilove</author>
      <pubDate>Thu, 06 Nov 2014 19:16:51 +0800</pubDate>
      <link>http://testerhome.com/topics/1563</link>
      <guid>http://testerhome.com/topics/1563</guid>
    </item>
    <item>
      <title>通过 xcode 查看 app crash 日志这个方法在 ios8 下面都查看不到了</title>
      <description>&lt;p&gt;通过xcode查看app crash 日志这个方法在ios8下面都查看不到了,请问大家都是怎么解决的?&lt;/p&gt;</description>
      <author>2014maggie</author>
      <pubDate>Tue, 04 Nov 2014 09:50:22 +0800</pubDate>
      <link>http://testerhome.com/topics/1557</link>
      <guid>http://testerhome.com/topics/1557</guid>
    </item>
    <item>
      <title>如何做好移动互联网应用测试 </title>
      <description>&lt;p&gt;首先很高兴的是移动测试会第八期在ucloud的赞助下非常非常圆满的成功了。人真的越来越多，妹子也越来越漂亮了。同时感谢小A和永达以及小马试驾创业公司的支持。移动测试会虽然最早是我个人创立的，但是一个人的能力毕竟有限，所以这第八期说明了团结就是力量：），也希望之后大家更多的来支持我们，本次活动的链接：&lt;a href="http://www.douban.com/event/22861768/" rel="nofollow" target="_blank"&gt;http://www.douban.com/event/22861768/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;11月8号支付宝上海要开始一天的专场招聘，所以最近我面试也非常的频繁。之前我写过一篇吐槽文章——《面试要求真的不高》，见链接：&lt;a href="http://testerhome.com/topics/1486" rel="nofollow" target="_blank"&gt;http://testerhome.com/topics/1486&lt;/a&gt;。今天的活动我也碰见了一些朋友来咨询我，所以在这里我想小小的谈论下如何进行移动无线应用的测试学习。&lt;/p&gt;

&lt;p&gt;为什么我定位移动无线互联网的测试，还是应用的测试呢，因为我个人就是做应用测试的，所以我系统测试也做过，不过不深入，所以我就不想去讨论自己不熟悉的领域了。其实在很久前我画过一张技能树的图，也许比较粗糙，但是也还是有价值的。blog链接见：&lt;a href="http://blog.sina.com.cn/s/blog_7022adbf0101b31w.html" rel="nofollow" target="_blank"&gt;http://blog.sina.com.cn/s/blog_7022adbf0101b31w.html&lt;/a&gt;&lt;br&gt;
&lt;img src="/photo/2014/9d538ddbf1c97b8c189ce15fb8520828.jpeg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;在之前的文章中也已经提到过了行业中的几类人，那么我们应该怎么如何客观的学习呢？请不要觉得自己已经工作很多时间就不愿意往下看了，反正看了你也不少块肉。请跟着以下的文字慢慢阅读，问问自己达到几点，不要自欺欺人就好。&lt;/p&gt;

&lt;p&gt;现在不会做测试的拼命到处问怎么做测试，现在在手动测试的拼命问怎么做自动化，现在做自动化的拼命问怎么写测试框架，现在写测试框架的拼命让团队使用，现在写框架并且让团队使用的拼命问除了维护框架还有什么别的可以做，现在没有事情做的拼命在问到底测试做什么呢？&lt;/p&gt;

&lt;p&gt;不知道每天会有多少人，每秒钟会有多少人会去问怎么做自动化，多少人会去问自己发展方向是什么，学习方向又是什么。我很明确的说，你没有方向原因在于你的无知，人最大的敌人就是恐惧和无知，两者相辅相成，最终就是一事无成。你问那么多有什么用，踏踏实实的先开始学有什么不好。&lt;br&gt;
  比如你要学习移动互联网的无线应用测试了，比如你要开始学习Android的应用测试了。那么首先第一步你先看google 提供的文档吧，sdk文档不说详细，先浏览一遍吧。然后既然你是一个做测试的，我们就说正常的道路，你至少先将文档中与test这个关键字相关的工具也好，框架也好看一下吧。不懂的可以随时google或者百度来帮助我们阅读完sdk的docs。什么？你从来不看官方文档？android是谁生的？你连亲爹妈都不看，那么你看啥？看后妈？然后抱怨怎么看不懂？你怪谁？&lt;/p&gt;

&lt;p&gt;ok，假设你老老实实的看完了，然后你说你了解你们产品的业务了，你就可以做应用的功能测试了吗？非也，试问大部分测试真的觉得自己够资格去做功能测试吗？觉得功能测试很简单吗？问起来很多人都很自信满满的说自己非常了解业务。ok，试问，你的app中每个功能对应哪些接口你知道吗？这些接口会有什么核心参数知道吗？试问，你的产品的核心代码你有阅读过吗？你的产品前端app对应的后台服务的代码你有阅读过吗？你说你测试的产品有视频是吧，视频格式有哪些？常见分辨率有哪几种？常见码流有哪些？如果这些你都不知道并不代表你不回做功能测试或者业务测试，而是你根本无法深层次的去设计测试用例，那么请问你这算会功能测试了吗？还有的同学和我说用户体验测试，ok，继续问，请问你看过google提供的android的UI Design Guide吗？也许你没有看过，也许你根本不知道，不管是哪条，那么还谈什么用户体验呢？简单来讲，我们做一个测试很简单，要深入做很困难，就如同今天移动测试会上茉莉说的wifi测试，也许让也许人去测试wifi测试也会测试，但是深入呢？我们做测试要踏踏实实，不要浮躁，浮躁只会让你继续sb，但是不会阻止别人nb。&lt;/p&gt;

&lt;p&gt;ok，假设功能测试的点你都清楚了，然后你说你技术多多少少知道点，然后你就可以去做应用的自动化测试了吗？非也。我们一个一个来看。大部分先来做的是UI Automation，ok，appium我在这边就不说了，也许2w字都吐槽吐不完，我就说robotium。那么你第一步是先看下robotium官方网站的sample和wiki，不要到处问例子或者直接上来就导入jar包去做。了解完毕之后，那么可以继续深入的去了解junit 和instrumentation，了解这两者能够让你对robotium更了解并且在写用例的时候更得心应手。然后你会写了sample，能够跑通就算ok了么？非也，那么接着碰见的问题就是如何管理suite，如何管理数据，比如testng，如何做参数配置，比如config.xml，如何进行用例的架构的维护，使用op等。接着如何将其集成到持续集成中？如果你仔细看过instrumentationtestrunner的官方文档你就不会问了。接着除了native的，也许会碰见自定义控件的自动化，最后还有webview和h5的自动化等。那么这些前提是你要先去了解这个自定义控件以及webview到底是什么吧，而不是直接拿robotium自定义的api直接食用，然后抱怨说，啊呀这个怎么跑不通。最后记得一定要结合业务去做设计和断言。&lt;br&gt;
  接着很多人还会觉得很牛逼的去找到BDD的框架，gem安装，套用cucumber和robotium。但是又会发现各种问题，在做这个事情之前继续试问，ruby gem管理你去学习了么？cucumber是啥知道了么？BDD框架源码结构有看过吗？step怎么封装知道吗？官方的github的wiki和issue有过一遍吗？都没有？那么你还问啥，先去看再做讨论。&lt;/p&gt;

&lt;p&gt;为什么我那么强调学习能力和态度，因为移动互联网的测试已经不是一个工具或者平台能够制霸的时代了。移动互联网现在更多的是注重实用开源框架，注重灵活的使用工具和代码来提升自己的效率，而不是拿来一个工具学会怎么用，然后就给你一个结果告诉你缺陷在什么地方。故而不是再去想什么“怎么做性能自动化测试”这种问题。无论你用360这种app也好，或者别的工具也罢，首先你拿到的数据并非是你公司团队想要的，其次请问这个数据你知道是怎么获取的吗？这个工具告诉你，cpu，内存，电量，流量，GPU绘制消耗，或者crash信息你就信啊？那么请问要你有啥用？你说你连数据怎么来的如果都不知道这个信息你敢用来作为测试报告吗？我们至少得自己去学习一下怎么获取这些数据吧，然后你编写service也好，使用shell也罢将这些做成自动化工具，那么也是有理有据。否则请问你真的会做自动化测试吗？最后记得一定要结合业务，那么势必要详细的了解业务，请看上面。可详见：&lt;a href="https://github.com/monkeytest15/AndroidPerformanceTest_Python" rel="nofollow" target="_blank"&gt;https://github.com/monkeytest15/AndroidPerformanceTest_Python&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接着来说安全测试也是一样。不要去想“有什么工具能够做安全测试啊？”。好了，这个问题我就不展开讨论了额，否则很多人肯定会觉得我在鄙视他们的智商。安全的测试和大部分人知道的测试根本就是两个领域，不要妄想你连上面几点都不知道的情况下就去做安全测试，真的不是我看不起你们。&lt;/p&gt;

&lt;p&gt;其实我们需要想象我们掌握的知识点是一个一个积木，而现在你先去看哪些积木你还没有，你先去获得。就比如java都不怎么会，然后就说自己要去做自动化，android都不了解就说要做自动化。没有太大必要。积木一个一个去搭，然后方向自然而然的就有了。目前学习移动无线的应用测试没有什么一定的路，每个人所在公司不同，所处业务不同，不要去问别人，最重要的是自己静下心来，记住，是静下心来问自己，自己真的不懂，如果自己是什么都不懂，那么就踏踏实实的从语言的学习，android本身的文档，工具等一个一个去学，不要浮躁。只要踏实了，不会没有方向，方向永远在你的心中。&lt;/p&gt;

&lt;p&gt;最后想强调一点的是，请眼光放长远，站在更高的高度看问题，不要做了10年还在做UI自动化，而且还根本做的不深入。记住，UI只不过是自动化中的冰山一角，你要去看的还有很多。不要局限自己，不要让公司局限你，除非你一辈子就打算在这个公司养老了。如果你不赞同我，那么随意，本来我就不指望所有人都点赞。&lt;/p&gt;

&lt;p&gt;by monkey&lt;/p&gt;</description>
      <author>monkey</author>
      <pubDate>Mon, 03 Nov 2014 11:28:22 +0800</pubDate>
      <link>http://testerhome.com/topics/1553</link>
      <guid>http://testerhome.com/topics/1553</guid>
    </item>
    <item>
      <title>[Share]解决 HTMLTestRunner 错误日志显示出界的问题</title>
      <description>&lt;h4&gt;问题解释&lt;/h4&gt;
&lt;p&gt;在使用HTMLTestRunner来生成HTML格式的测试报告中，如果存在failed或者error状态的case，就会附有错误日志，但在截图中可以明显的看到错误日志显示出界，没有自动折行。&lt;br&gt;
&lt;img src="https://app.yinxiang.com/shard/s25/sh/595ecd10-d6d8-47ac-84af-31b8a348fe67/573d7209bf47b6544baa8af2a29dc1ea/deep/0/Unit-Test-Report.png" alt="显示出界"&gt;&lt;/p&gt;
&lt;h4&gt;解决方法&lt;/h4&gt;
&lt;p&gt;对于这个问题，我想了一个笨办法，既然不能强制折行，那就把背后的区域放大，让它看起来没有出界，不就OK了嘛，算是变相解决吧。&lt;/p&gt;

&lt;p&gt;1.使用Chrome的Developer Tools就可以看到其背后的区域样式属于.popup_window，而我们只需要去掉其中Width的宽度限制就可以了&lt;br&gt;
&lt;img src="/photo/2014/152728bfe46b90da41b41580ec9d3b2a.png" alt="样式截图1"&gt;&lt;br&gt;
&lt;img src="https://app.yinxiang.com/shard/s25/sh/45df67e9-972c-441c-ae14-a3bb02064113/9c1465f106d59b9c56a02e6187432993/deep/0/Unit-Test-Report.png" alt="样式截图2"&gt;&lt;/p&gt;

&lt;p&gt;2.打开HTMLTestRunner.py(基于Github上最新的代码)，修改其中的第352行后保存（注释或删掉都可以），具体如下所示：&lt;/p&gt;
&lt;pre class="highlight css"&gt;&lt;span class="nc"&gt;.popup_window&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;display&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;none&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;position&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;relative&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="m"&gt;0px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;top&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="m"&gt;0px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c"&gt;/*border: solid #627173 1px; */&lt;/span&gt;
    &lt;span class="nl"&gt;padding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="m"&gt;10px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;background-color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="m"&gt;#E6E6D6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;font-family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;"Lucida Console"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;"Courier New"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Courier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;monospace&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;text-align&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;font-size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="m"&gt;8pt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c"&gt;/*width: 500px; */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;3.再次运行你的测试脚本&lt;/p&gt;
&lt;h4&gt;现象截图&lt;/h4&gt;
&lt;p&gt;修改后的效果&lt;br&gt;
&lt;img src="https://app.yinxiang.com/shard/s25/sh/55a4cc07-b6bd-4c12-acd6-65af9abf487e/29df31c8bde2c049a41f3e2ef06ad637/deep/0/Unit-Test-Report.png" alt="修改后"&gt;&lt;/p&gt;</description>
      <author>xiaomayi0323</author>
      <pubDate>Thu, 30 Oct 2014 20:46:21 +0800</pubDate>
      <link>http://testerhome.com/topics/1547</link>
      <guid>http://testerhome.com/topics/1547</guid>
    </item>
    <item>
      <title>【业界良心】Testin 发布世界首款支持游戏控件识别的开源自动化框架</title>
      <description>&lt;p&gt;&lt;a href="https://github.com/testinlab/cocos-plugin" rel="nofollow" target="_blank"&gt;https://github.com/testinlab/cocos-plugin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Testin成立了开源实验室. 并发布了首个开源项目. 基于游戏控件识别技术的游戏自动化测试框架. cocos-plugin&lt;br&gt;
这也是世界上首个基于游戏控件识别技术的开源自动化框架.&lt;/p&gt;
&lt;h4&gt;cocos-plugin&lt;/h4&gt;
&lt;p&gt;cocos手游录制插件，用于添加Testin手游自动化测试支持，支持cocos2d-x和cocos2d-js全版本游戏引擎，包括cocos2d-x 2.x、cocos2d-x 3.x、cocos2d-js 3.x。&lt;/p&gt;

&lt;p&gt;框架基于cocos框架的. 基于C编程语言. 需要以插件的形式嵌入应用内部. 更多功能请访问github项目.&lt;/p&gt;

&lt;p&gt;公司也有itestin录制工具, 在即将发布的新版本中会加入基于游戏控件的录制回放功能. &lt;br&gt;
视频制作好后, 我会发布对应的演示教程. &lt;/p&gt;

&lt;p&gt;此前已经通过坐标方式支持不同分辨率的游戏流程录制了.&lt;/p&gt;

&lt;p&gt;下载地址:&lt;br&gt;
&lt;a href="http://www.testin.cn/portal.action?op=Portal.iTestin" rel="nofollow" target="_blank"&gt;http://www.testin.cn/portal.action?op=Portal.iTestin&lt;/a&gt;&lt;/p&gt;</description>
      <author>seveniruby</author>
      <pubDate>Fri, 24 Oct 2014 15:58:18 +0800</pubDate>
      <link>http://testerhome.com/topics/1517</link>
      <guid>http://testerhome.com/topics/1517</guid>
    </item>
    <item>
      <title>启动 Hierarchy Viewer 出错</title>
      <description>&lt;p&gt;如下图所示，提示错误，怎么解决。 是必须要root么？&lt;/p&gt;

&lt;p&gt;&lt;img src="/photo/2014/3a4f1217da2225604363ccb8594b606b.png" alt=""&gt;&lt;/p&gt;</description>
      <author>shijin880921</author>
      <pubDate>Tue, 21 Oct 2014 23:32:31 +0800</pubDate>
      <link>http://testerhome.com/topics/1507</link>
      <guid>http://testerhome.com/topics/1507</guid>
    </item>
  </channel>
</rss>
